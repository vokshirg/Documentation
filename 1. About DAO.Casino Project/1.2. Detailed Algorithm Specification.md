# Table of Contents
1. [Executive Summary](#executivesummary)  
    1.1. [Algorithm Security](#algorithmsecurity)  
    1.2. [Randomization Quality](#randomizationquality)
2. [Algorithm](#algorithm)  
    2.1. [Algorithm Specification](#algorithmspecification)  
    2.2. [Adversary's Goals](#adversarysgoals)  
3. [Overview of Known RSA Attacks](#overviewofknownrsaattacks)  
    3.1. [RSA Homomorphic Encryption](#rsahomomorphicencryption)  
    3.2. [Alternative Key Generation](#alternativekeygeneration)  
    3.3. [Low Private Exponent Attack](#lowprivateexponentattack)  
    3.4. [Low Public Exponent Attacks](#lowpublicexponentattacks)  
    3.5. [Common Modulus and Davida's Attacks](#commonmodulusdavidasattack)  
    3.6. [Blind Signature Attack](#blindsignatureattack)  
    3.7. [Random Fault Attack with the Use of CRT](#randomfaultattackwiththeuseofcrt)
4. [Statistical tests](#statisticaltests)  
    4.1. [Overview](#overview)  
    4.2. [Graphical tests](#graphicaltests)  
    4.3  [NIST Statistical tests](#niststatisticaltests)

# Executive Summary <a name="executivesummary"></a>

Signidice algorithm has been analyzed with regard to the following parameters:

- **Security**. The algorithm applies the digital RSA signature; an instance was submitted to a range of test attacks.
- **Number generation quality**. The algorithm is intended for fair random number generation (FRNG) within games. Therefore, we performed a range of tests to identify the quality of randomization.

All in all, the results are quite positive for both parameters. No attacks able of damaging the algorithm within a specific time-frame seem to exist. Likewise,  sequences obtained via the suggested algorithm can be considered close to truly random.  

## Algorithm security <a name="algorithmsecurity"></a>

We emulated a range of popular attacks against RSA algorithms to test our solution, namely:

- RSA homomorphic attack
- Аlternative keys
- Low private exponent attack
- Low public exponent attack
- Common modulus
- Davida's attack
- Blind signature attack
- Random faults

The results proved that the solution resists attacks well; moreover, no other fraud sequences applicable to our protocol have been detected so far.

## Randomization Quality <a name="randomizationquality"></a>

We researched statistics of sequences generated via Signidice. Two stages of tests were performed, namely, graphic statistical tests and NIST test suites.

In the framework of graphic tests two sequences were used: one obtained with RSA signature and the other generated by Random.org for reference. The test set based on 'Methods and Tools for Pseudo-Random Number Generators Quality Evaluation’ book by M. Ivanov and I. Chugunkov’ included the following tests:

- Data distribution in histogram
- Lag-plot
- Bit  series distribution
- Monotonicity evaluation
- Autocorrelation plot (correlograms)

All tests proved that the generated sequence is close to being truly random. Given minor discrepancy between the tested and the reference sequences, we can claim that the suggested algorithm delivers high quality random number generation.

NIST statistical tests are only applicable to RSA sequences and using a reference sequence is not feasible. The following tests were performed:

- Frequency (monobit) test
- Frequency test within a block
- Cumulative sums (Cusums) test
- Runs test
- Longest Run-of-ones in a block test
- Binary matrix rank test
- Discrete Fourier transform (spectral) test
- Non-Overlapping (Aperiodic) Template Matching Test
- Approximate entropy test
- Serial test

These test also yielded positive results and backed conclusions of the above test set with regard to randomization quality.

# Algorithm <a name="algorithm"></a>

## Algorithm Specification <a name="algorithmspecification"></a>

The specification below provides an abridged description of our version of Signidice. While applied issues are omitted, the document focuses on cryptographic transformations.

Let's assume that the game involves three participants: Casino (B), player (P), smart contract (C).

1. **B** Generates RSA parameters. 

Then, under the suggested algorithm,  for the specified public exponent *e* and a key length of B=2048 bit *p* and *q* are generated as follows:

- *q* length is defined: 

 <a href="http://www.codecogs.com/eqnedit.php?latex=qs&space;=&space;B&space;>>&space;1&space;(1024&space;bit&space;for&space;B&space;=&space;2048)" target="_blank"><img src="http://latex.codecogs.com/gif.latex?qs&space;=&space;B&space;>>&space;1&space;(1024&space;bit&space;for&space;B&space;=&space;2048)" title="qs = B >> 1 (1024 bit for B = 2048)" /></a>



- As the result of enumeration we get a p number with a length of *B-qs,* so that bits for the number come from an RC4-based generator.


<a href="https://www.codecogs.com/eqnedit.php?latex=GCD(p&space;-&space;1,&space;e)&space;=&space;1" target="_blank"><img src="https://latex.codecogs.com/gif.latex?GCD(p&space;-&space;1,&space;e)&space;=&space;1" title="GCD(p - 1, e) = 1" /></a>


  *p* is a prime number, probability is: <a href="http://www.codecogs.com/eqnedit.php?latex=1&space;-&space;0.5^t&space;(t&space;=&space;10)" target="_blank"><img src="http://latex.codecogs.com/gif.latex?1&space;-&space;0.5^t&space;(t&space;=&space;10)" title="1 - 0.5^t (t = 10)" /></a>
 (use the Miller-Rabin primality test to check it).

- The *q* number of *qs* length is generated the same way.
  The next step is to check the following condition: 
  
  <a href="http://www.codecogs.com/eqnedit.php?latex=GCD((p-1)(q-1),e&space;)=1" target="_blank"><img src="http://latex.codecogs.com/gif.latex?GCD((p-1)(q-1),e&space;)=1" title="GCD((p-1)(q-1),e )=1" /></a>

  If it cannot be met, *p* and *q* are regenerated.

  Once the condition is met, the modulus is calculated:

<a href="http://www.codecogs.com/eqnedit.php?latex=N&space;=&space;p&space;*&space;q" target="_blank"><img src="http://latex.codecogs.com/gif.latex?N&space;=&space;p&space;*&space;q" title="N = p * q" /></a>

  Then, the private key is calculated in the following way.

<a href="http://www.codecogs.com/eqnedit.php?latex=d=&space;e^{-1}mod&space;\varphi&space;(N)" target="_blank"><img src="http://latex.codecogs.com/gif.latex?d=&space;e^{-1}mod&space;\varphi&space;(N)" title="d= e^{-1}mod \varphi (N)" /></a>, where <a href="https://www.codecogs.com/eqnedit.php?latex=\varphi(N)&space;=&space;(p&space;-&space;1)(q&space;-&space;1)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\varphi(N)&space;=&space;(p&space;-&space;1)(q&space;-&space;1)" title="\varphi(N) = (p - 1)(q - 1)" /></a>

  Then generation is complete.

2. **B**: Writes *N* and *e* to Smart Contract (**C**).

3. **P**: Generates a random number *R (R < N)* and transmits it to **B** and **C**
   
4. **C**: Checks whether *R* has been used before.
   
5. **B, C**: Calculate *V*:

<a href="http://www.codecogs.com/eqnedit.php?latex=V&space;=&space;SHA(R,&space;meta)" target="_blank"><img src="http://latex.codecogs.com/gif.latex?V&space;=&space;SHA(R,&space;meta)" title="V = SHA(R, meta)" /></a>

Where *meta* stands for metadata related to the game channel (game ID, round number etc.)

6. **B**: Calculates S: 

<a href="http://www.codecogs.com/eqnedit.php?latex=S=&space;RSA_{Sign}(V)=&space;V^{^{d}}mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?S=&space;RSA_{Sign}(V)=&space;V^{^{d}}mod&space;N" title="S= RSA_{Sign}(V)= V^{^{d}}mod N" /></a>

Then, checks whether the signature has been generated correctly and sends it to **P** and **C**.

3. **P and C:** Check the signature with the use of an open key *e:*

<a href="http://www.codecogs.com/eqnedit.php?latex=S^{e}&space;mod&space;N==V&space;?" target="_blank"><img src="http://latex.codecogs.com/gif.latex?S^{e}&space;mod&space;N==V&space;?" title="S^{e} mod N==V ?" /></a>


The final signature generates game results and distributes rewards.

## Adversary's Goals <a name="adversarysgoals"></a>

For the player (**P**):

- To predict the signature result and make the right bid.
- Get the necessary result during the signature process.

For the casino (**B**):

- To forge the signature result to change the game result in the favor of casino.

# Overview of Known RSA Attacks <a name="overviewofknownrsaattacks"></a>

Attacks were selected on the basis of 2006 article “[Mathematical Attacks on RSA Cryptosystem](http://thescipub.com/pdf/10.3844/jcssp.2006.665.671)”, by Imad Khaled Salah, Abdullah Darwish and Saleh Oqeili. Apart from attacks mentioned there, we included the alternative key generation threat.  
***Note that we expect the audience of this chapter to be familiar with the basics of modular arithmetic.***

## RSA Homomorphic Encryption <a name="rsahomomorphicencryption"></a>

With regard to multiplication, an unpadded RSA is a partially homomorphic encryption algorithm. In math terms in means:


<a href="http://www.codecogs.com/eqnedit.php?latex=RSA(m1)*RSA(m2)=RSA(m1*m2)" target="_blank"><img src="http://latex.codecogs.com/gif.latex?RSA(m1)*RSA(m2)=RSA(m1*m2)" title="RSA(m1)*RSA(m2)=RSA(m1*m2)" /></a>

Let’s assume that a player **P** sends two numbers (*m1* and *m2*) for signing and receives the following signatures:

<a href="http://www.codecogs.com/eqnedit.php?latex=s_{1}=m_{1}^{в}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?s_{1}=m_{1}^{в}&space;mod&space;N" title="s_{1}=m_{1}^{в} mod N" /></a>

<a href="http://www.codecogs.com/eqnedit.php?latex=s_{2}=m_{2}^{в}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?s_{2}=m_{2}^{в}&space;mod&space;N" title="s_{2}=m_{2}^{в} mod N" /></a>

Then **P** sends _m3=m1*m2_ for signing, and the following is true:



<a href="http://www.codecogs.com/eqnedit.php?latex=s_{3}=m_{3}^{d}&space;mod&space;N=&space;(m_{1}*m_{2})^{d}&space;mod&space;N=(m_{1}^{d}*m_{2}^{d})&space;mod&space;N=&space;m_{1}^{d}&space;mod&space;N*&space;m_{2}^{d}mod&space;N=s_{1}*s_{2}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?s_{3}=m_{3}^{d}&space;mod&space;N=&space;(m_{1}*m_{2})^{d}&space;mod&space;N=(m_{1}^{d}*m_{2}^{d})&space;mod&space;N=&space;m_{1}^{d}&space;mod&space;N*&space;m_{2}^{d}mod&space;N=s_{1}*s_{2}&space;mod&space;N" title="s_{3}=m_{3}^{d} mod N= (m_{1}*m_{2})^{d} mod N=(m_{1}^{d}*m_{2}^{d}) mod N= m_{1}^{d} mod N* m_{2}^{d}mod N=s_{1}*s_{2} mod N" /></a>

In this case a player is well aware of the signature result in advance, in the given example the result every time is calculated as follows:

<a href="http://www.codecogs.com/eqnedit.php?latex=s_{1}=V_{1}^{d}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?s_{1}=V_{1}^{d}&space;mod&space;N" title="s_{1}=V_{1}^{d} mod N" /></a>

<a href="http://www.codecogs.com/eqnedit.php?latex=s_{2}=V_{2}^{d}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?s_{2}=V_{2}^{d}&space;mod&space;N" title="s_{2}=V_{2}^{d} mod N" /></a>

Then, to perform an attack a player has to pick an *R* to satisfy the following condition:

<a href="http://www.codecogs.com/eqnedit.php?latex=V_{3}=V_{1}*V_{2}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?V_{3}=V_{1}*V_{2}&space;mod&space;N" title="V_{3}=V_{1}*V_{2} mod N" /></a>

But *V<sub>3</sub>* is a SHA hashing result from *R* and a metadata set that cannot be tampered by any of the players. Thus, SHA cryptologic resistance prevents obtaining the right *R* within the given time frame.

## Alternative Key Generation <a name="alternativekeygeneration"></a>

The alternative key generation concept implies that the same message encrypted with multiple private keys remains valid. Note that the whole strategy is based on the fact that a signature (i.e. an encrypted message) appears both valid and unchanged regardless of which alternative key is applied.
To demonstrate it, let's consider the widely used formula for alternative key generation and see how a message signed with an alternative key appears to be identical to the original one.  
The following parameters set the RSA system:

- N – system modulus
- e – public key
- d – private key

Let's define a message *m*; the message is a number < *N*. The element order *a modulo m* is the smallest positive integer *l* satisfying the following:


<a href="http://www.codecogs.com/eqnedit.php?latex=a^{l}\equiv&space;1&space;mod&space;m" target="_blank"><img src="http://latex.codecogs.com/gif.latex?a^{l}\equiv&space;1&space;mod&space;m" title="a^{l}\equiv 1 mod m" /></a>

The order of the message modulo *N* is:

<a href="http://www.codecogs.com/eqnedit.php?latex=r=ord&space;(m)mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?r=ord&space;(m)mod&space;N" title="r=ord (m)mod N" /></a>

Then:

<a href="http://www.codecogs.com/eqnedit.php?latex=m^{r}\equiv&space;1&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?m^{r}\equiv&space;1&space;mod&space;N" title="m^{r}\equiv 1 mod N" /></a>

Given that *d* is a private key, all alternative encryption keys <a href="https://www.codecogs.com/eqnedit.php?latex=d_{a}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?d_{a}" title="d_{a}" /></a> for a message *m* have the following format:


<a href="http://www.codecogs.com/eqnedit.php?latex=d_{a}\equiv&space;≡d&space;mod&space;r" target="_blank"><img src="http://latex.codecogs.com/gif.latex?d_{a}\equiv&space;≡d&space;mod&space;r" title="d_{a}\equiv d mod r" /></a>


If *r* values are comparable, <a href="https://www.codecogs.com/eqnedit.php?latex=d_{a}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?d_{a}" title="d_{a}" /></a> can be expressed in the following way:

<a href="http://www.codecogs.com/eqnedit.php?latex=d_{a}=d&plus;i*r" target="_blank"><img src="http://latex.codecogs.com/gif.latex?d_{a}=d&plus;i*r" title="d_{a}=d+i*r" /></a>, for  some   *i ϵ Z*  

Valid key message signature can be then expressed as follows:

<a href="http://www.codecogs.com/eqnedit.php?latex=s=m^{d}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?s=m^{d}&space;mod&space;N" title="s=m^{d} mod N" /></a>

And, alternative key message signature has the following format:

<a href="http://www.codecogs.com/eqnedit.php?latex=s'=&space;m^{d_{a}}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?s'=&space;m^{d_{a}}&space;mod&space;N" title="s'= m^{d_{a}} mod N" /></a>

Given that 

<a href="http://www.codecogs.com/eqnedit.php?latex=d_{a}=d&plus;ir" target="_blank"><img src="http://latex.codecogs.com/gif.latex?d_{a}=d&plus;ir" title="d_{a}=d+ir" /></a>

we have 

<a href="http://www.codecogs.com/eqnedit.php?latex=m^{d_{a}}&space;mod&space;N=m^{d&plus;ir}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?m^{d_{a}}&space;mod&space;N=m^{d&plus;ir}&space;mod&space;N" title="m^{d_{a}} mod N=m^{d+ir} mod N" /></a>

Let's apply the degree properties :

<a href="http://www.codecogs.com/eqnedit.php?latex=m^{d&plus;i*r}&space;mod&space;N=&space;m^{d}*m^{i*r}&space;mod&space;N=&space;m^{d}*(m^{r})^{i}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?m^{d&plus;i*r}&space;mod&space;N=&space;m^{d}*m^{i*r}&space;mod&space;N=&space;m^{d}*(m^{r})^{i}&space;mod&space;N" title="m^{d+i*r} mod N= m^{d}*m^{i*r} mod N= m^{d}*(m^{r})^{i} mod N" /></a>

As we mentioned previously:

<a href="http://www.codecogs.com/eqnedit.php?latex=m^{r}\equiv1&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?m^{r}\equiv1&space;mod&space;N" title="m^{r}\equiv1 mod N" /></a>

therefore, the following is true:

<a href="http://www.codecogs.com/eqnedit.php?latex=m^{d}*(m^{r})^{i}&space;mod&space;N&space;\equiv&space;m^{d}*(1)^{i}&space;mod&space;N=&space;m^{d}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?m^{d}*(m^{r})^{i}&space;mod&space;N&space;\equiv&space;m^{d}*(1)^{i}&space;mod&space;N=&space;m^{d}&space;mod&space;N" title="m^{d}*(m^{r})^{i} mod N \equiv m^{d}*(1)^{i} mod N= m^{d} mod N" /></a>

The obtained equation represents the valid key signature:

<a href="http://www.codecogs.com/eqnedit.php?latex=m^{d}&space;mod&space;N=s" target="_blank"><img src="http://latex.codecogs.com/gif.latex?m^{d}&space;mod&space;N=s" title="m^{d} mod N=s" /></a>

The above steps allow concluding that both valid and alternative key signatures do look identical:

<a href="http://www.codecogs.com/eqnedit.php?latex=s'=&space;m^{d_{a}}&space;mod&space;N\equiv&space;m^{d&plus;i*r}&space;mod&space;N\equiv&space;m^{d}*m^{i*r}&space;mod&space;N\equivm^{d}*(m^{r})^{i}&space;mod&space;N\equiv&space;m^{d}*(1)^{i}&space;mod&space;N\equiv&space;m^{d}&space;mod&space;N=s" target="_blank"><img src="http://latex.codecogs.com/gif.latex?s'=&space;m^{d_{a}}&space;mod&space;N\equiv&space;m^{d&plus;i*r}&space;mod&space;N\equiv&space;m^{d}*m^{i*r}&space;mod&space;N\equivm^{d}*(m^{r})^{i}&space;mod&space;N\equiv&space;m^{d}*(1)^{i}&space;mod&space;N\equiv&space;m^{d}&space;mod&space;N=s" title="s'= m^{d_{a}} mod N\equiv m^{d+i*r} mod N\equiv m^{d}*m^{i*r} mod N\equivm^{d}*(m^{r})^{i} mod N\equiv m^{d}*(1)^{i} mod N\equiv m^{d} mod N=s" /></a>

## Low Private Exponent Attack (Wiener's Attack) <a name="lowprivateexponentattack"></a>

When a private key *d* is small enough, an attacker can expose it. Let's consider the theorem below (without proof):  

  _Let_ <a href="http://www.codecogs.com/eqnedit.php?latex=N&space;=&space;p&space;*&space;q" target="_blank"><img src="http://latex.codecogs.com/gif.latex?N&space;=&space;p&space;*&space;q" title="N = p * q" /></a>_, where_ <a href="http://www.codecogs.com/eqnedit.php?latex=q&space;<&space;p&space;<&space;2*q" target="_blank"><img src="http://latex.codecogs.com/gif.latex?q&space;<&space;p&space;<&space;2*q" title="q < p < 2*q" /></a>. _Let's also assume that_ <a href="http://www.codecogs.com/eqnedit.php?latex=1/3&space;*&space;N^{0.25}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?1/3&space;*&space;N^{0.25}" title="1/3 * N^{0.25}" /></a>_._  
  _Suppose that an attacker has a public key (e, N); then he can effectively determine d._


Considering the attack itself is out of the scope of the present explanation, the given theorem suffices to illustrate vulnerability.
Note that in its current realization the public exponent e is fixed and equals 65537  *d* is generated randomly so that:

<a href="http://www.codecogs.com/eqnedit.php?latex=d\equiv&space;e^{-1}&space;mod&space;\varphi&space;(N)" target="_blank"><img src="http://latex.codecogs.com/gif.latex?d\equiv&space;e^{-1}&space;mod&space;\varphi&space;(N)" title="d\equiv e^{-1} mod \varphi (N)" /></a>

Both parts are then multiplied by *e*:

<a href="http://www.codecogs.com/eqnedit.php?latex=de\equiv&space;1&space;mod&space;\varphi&space;(N)" target="_blank"><img src="http://latex.codecogs.com/gif.latex?de\equiv&space;1&space;mod&space;\varphi&space;(N)" title="de\equiv 1 mod \varphi (N)" /></a>

The modular equation definition yields:

<a href="http://www.codecogs.com/eqnedit.php?latex=de&space;=&space;1&space;&plus;k*\varphi&space;(N)" target="_blank"><img src="http://latex.codecogs.com/gif.latex?de&space;=&space;1&space;&plus;k*\varphi&space;(N)" title="de = 1 +k*\varphi (N)" /></a>

*d* is expressed as follows:

<a href="http://www.codecogs.com/eqnedit.php?latex=d=\frac{1&plus;k\varphi&space;(N)e}{e}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?d=\frac{1&plus;k\varphi&space;(N)e}{e}" title="d=\frac{1+k\varphi (N)e}{e}" /></a>

It appears that *(N)'s* value is comparable to that of *N* itself, <a href="http://www.codecogs.com/eqnedit.php?latex=e\approx&space;2^{16}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?e\approx&space;2^{16}" title="e\approx 2^{16}" /></a>  minimal k = 1. Then, *d* can be expressed as:

<a href="http://www.codecogs.com/eqnedit.php?latex=d\approx&space;\frac{N}{2^{16}}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?d\approx&space;\frac{N}{2^{16}}" title="d\approx \frac{N}{2^{16}}" /></a>
     	
 Let's compare the obtained number to the one from the theorem. Let’s visualize them as *N* functions.

​	**![img](https://lh4.googleusercontent.com/sZh4AeyVvoWQ9l4-XWTkYLTx5Dzj8TizB3EUer191gdrSRO_I803MwAztvgfRwg_2-IbYX3Itms1CF4I8o5vNzU4vSFqUtaqHzCRkqEp978ONfmgwKy4hBtmmUivxmgGJ8etwH2H)**  

 The green line on the graph indicates the function <a href="http://www.codecogs.com/eqnedit.php?latex=1/3&space;*&space;N^{0.25}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?1/3&space;*&space;N^{0.25}" title="1/3 * N^{0.25}" /></a>, whereas <a href="http://www.codecogs.com/eqnedit.php?latex=\frac{N}{2^{16}}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\frac{N}{2^{16}}" title="\frac{N}{2^{16}}" /></a> is indicated by a red line. It appears that even with low values (graphs were constructed for *N* value from 0 to 2^20) the encrypting exponents of the regarded algorithm realization do exceed the required threshold.  
With N values going up the gap also is also increasing (till *N = 2^100*):

**![img](https://lh5.googleusercontent.com/WaeM0DeLF5mM2IgG_j6EltNKShEmZZiOSj6A7DhwVfdpiE6vUrOfVkvANEpa-lgwFStp10twKK8EVMb082F4Isz10swm5Q4SOolOJDiDXOs85PuysnW5UyJ3GbW2_5iqjINkcPn8)** 



RSA required much larger numbers, with a higher private key security threshold.

## Low Public Exponent Attacks <a name="lowpublicexponentattacks"></a>

Most part of detected LPE attacks only expose signed messages. Given that in Signidice signed messages are public, this attack type is useless save for one exception. The private key *d* is exposed if its minor <a href="http://www.codecogs.com/eqnedit.php?latex=\frac{n}{4}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\frac{n}{4}" title="\frac{n}{4}" /></a> (where *n* stands for an RSA modulus) is obtained  by an attacker. Yet, a casino's private key stored locally is not supposed to be transmitted, rendering the attack highly unlikely.

## Common Modulus and Davida's Attacks <a name="commonmodulusdavidasattack"></a>

Both of these attacks can be used only for reading the signed message. 

## Blind Signature Attack <a name="blindsignatureattack"></a>

 Let’s assume that an adversary wants Bob to sign the message *M* without knowing it. For that purpose, the adversary has to take the following steps:

1.  Chooses a random *r* number.
2.  Computes <a href="http://www.codecogs.com/eqnedit.php?latex=M^{'}&space;=&space;r^{e}*M" target="_blank"><img src="http://latex.codecogs.com/gif.latex?M^{'}&space;=&space;r^{e}*M" title="M^{'} = r^{e}*M" /></a>, where *e* is a public exponent.
3. Sends *M'* for signing.

Now the adversary can compute the signature as follows:
<a href="http://www.codecogs.com/eqnedit.php?latex=S&space;=S^{'}/r&space;=(M^{'d}&space;mod&space;N)&space;/&space;r&space;=(&space;(r^{e}*M)^{d}&space;mod&space;N)&space;/&space;r&space;=&space;(r*M^{d}&space;mod&space;N)&space;/&space;r=M^{d}&space;mod&space;N" target="_blank"><img src="http://latex.codecogs.com/gif.latex?S&space;=S^{'}/r&space;=(M^{'d}&space;mod&space;N)&space;/&space;r&space;=(&space;(r^{e}*M)^{d}&space;mod&space;N)&space;/&space;r&space;=&space;(r*M^{d}&space;mod&space;N)&space;/&space;r=M^{d}&space;mod&space;N" title="S =S^{'}/r =(M^{'d} mod N) / r =( (r^{e}*M)^{d} mod N) / r = (r*M^{d} mod N) / r=M^{d} mod N" /></a> 


Similar to the above RSA homomorphic attack, this one is not applicable to the suggested algorithm, as there is a hash function applied to data sent to a casino for signing. Given the security level, we are certain that a player will not be able to calculate the value satisfying the following expression:

<a href="http://www.codecogs.com/eqnedit.php?latex=SHA256(M)&space;=&space;r^{e}*SHA256(M^{'})" target="_blank"><img src="http://latex.codecogs.com/gif.latex?SHA256(M)&space;=&space;r^{e}*SHA256(M^{'})" title="SHA256(M) = r^{e}*SHA256(M^{'})" /></a>
 	

## Random Fault Attack with the Use of CRT <a name="randomfaultattackwiththeuseofcrt"></a>

 An <a href="http://www.codecogs.com/eqnedit.php?latex=N&space;=&space;p&space;*&space;q" target="_blank"><img src="http://latex.codecogs.com/gif.latex?N&space;=&space;p&space;*&space;q" title="N = p * q" /></a> factorization and CRT based algorithm can be utilized to accelerate the raising to power with a  modular exponentiation. In case of any fault a  adversary will be able to expose *p* and *q*. 
However, this fault can only eventually lead to an invalid signature. Our algorithm has its signature validity checked every time before publishing, which means a  adversary is unable to obtain it in case of an unexpected fault.

# Statistical tests <a name="statisticaltests"></a>

## Overview <a name="overview"></a>

A part of Signidice is considered as a pseudorandom number generator (further on referred to as the **Generator**) that operates in the following way:

1.  Generates a certain value V on the basis of a player random number and metadata; this value is signed by a bankroller. 
2. Then the modular remainder of 128 is taken from the obtained signature. The resulting number (0 to 127 included) represents the generator output.

Tests were performed in two stages: graphic statistical tests and NIST test suites.
Unlike real-life algorithm, no random numbers were input to the generator; arithmetic sequences like x, x+1, x+2, x+3.... where x is a random seed,  were applied instead. The purpose is to ensure more control over dependencies and potential non-randomness and to demonstrate that even in the given environment output is quite close to being truly random (further the input method is referred to as a counter mode). Also, normal distribution number selection tests were performed. Results matched those obtained with the counter mode applied, therefore these tests are not covered here.

## Graphical tests <a name="graphicaltests"></a>

In the course of testing two sequences were used:  one obtained from the generator operation in counter mode and the other generated at Random.org for reference. 

The test set included the following (based on 'Methods and Tools for Pseudo-Random Number Generators Quality Evaluation’ by M. Ivanov and  I. Chugunkov):

- Data distribution in a histogram
- Lag-plot
- Bit series distribution
- Evaluating monotonicity
	 Autocorrelation plot (correlograms)	

Sequences of different N length were used in the testing, which is explained by test requirements, some of which need a bigger amount of input data, while others might only need sequences of 10000 elements.

#### Data Distribution in a Histogram

This test is aimed at identifying quality of distribution of elements in a sample (*N*). The histogram is based on element occurrence frequency. 

Smaller difference between bars of juxtaposed charts indicates a higher generation quality.

*N = 100 000.*

##### Test results (comparison charts)

**![img](https://lh5.googleusercontent.com/2TLWyOXWpBIfZ8oaRuz5_ZRwiTSJdsWlaWpylIdmm7COv-zPKZkBlzzUXTkzK4xMxyo7AnGO_sBTvYrpZ6ZojN9EUiE_krbxvIxaLUXk6dl6ouCYNoTEf1L_CvO9NIKmDvTAOvwn)** 

**![img](https://lh4.googleusercontent.com/LUZ17tFKP0B4lDq8xx65EtYovkJ8Fz_8ZXf83C_HPth9ZFyOHG35A0rQnGMKZhPtePj9Q8DmVryuDXsyXDO0tQV_soOW9SnwrV35J_OZJ627MeK9fD0nPEHPL5-mIdVKUCpt4PYu)** 

**![img](https://lh4.googleusercontent.com/dmlnax7YwCdZpDClYSGD_7ZGwyl5V38l7AFH8VXjf0GVJs5112PLbPiJC-xlEk538swxLeky0fXzx-4unl2HmKXfU7BsAmTa8zbuJ8ctC2H1ElgWdjQp_IL9rhqZizdEs5XyaOtE)** 

Test results prove low difference in bar heights of both samples; similarly, the frequency of elements is acceptable.

#### Lag-plot

This test is intended for identifying the dependence between the sequence elements.
Sequence <a href="http://www.codecogs.com/eqnedit.php?latex=e_{1},e_{2},...,e_{N}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?e_{1},e_{2},...,e_{N}" title="e_{1},e_{2},...,e_{N}" /></a> is demonstrated on the chart as coordinate points <a href="http://www.codecogs.com/eqnedit.php?latex=(e_{i},e_{i&plus;1})" target="_blank"><img src="http://latex.codecogs.com/gif.latex?(e_{i},e_{i&plus;1})" title="(e_{i},e_{i+1})" /></a>.

Sequence <a href="http://www.codecogs.com/eqnedit.php?latex=e_{1},e_{2},...,e_{N}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?e_{1},e_{2},...,e_{N}" title="e_{1},e_{2},...,e_{N}" /></a> coordinates points <a href="http://www.codecogs.com/eqnedit.php?latex=(e_{i},e_{i&plus;1})" target="_blank"><img src="http://latex.codecogs.com/gif.latex?(e_{i},e_{i&plus;1})" title="(e_{i},e_{i+1})" /></a> are added to the plot.

The charts below clearly illustrate chaotic positioning of dots and the absence of visible pattern which prove that a sequence is random.  If the tested sequence *N* is incremented, the field is going to be eventually fully covered with dots.  

*N = 10 000*  

##### Test Result Charts

**![img](https://lh3.googleusercontent.com/PWWl0kbsisbfwWwNZyf-d9A9_7QJcGmJ4fZ_pdAWwms9RpKPK6ovv4Qz0TpaeMHxU9l6pDAVokzLk_JF08XhfwxJ4RWeMVdduRuFAD1338QWZo9Vgf4mizuKpN8WaIS-4lrThXkB)** 

**![img](https://lh5.googleusercontent.com/PT9gtedOjycYqEF11kwYyA0UEJDFfaWKmNhiMgnNAMfkAVeHnS4bmp6w58reYxvX91kv32Iex7jOfJkYCp0U4tN4lByzvfEcPltB_1MJuyga2ZZlXma1l9Nuwr6xhdXCCyHxSYMk)** 

#### Bit Series Distribution


Tests for *n = 1, 2, 3 were performed.  The results allow identifying the n-gram bit distribution equality represented as sequence bits. Random sequences have equal distribution; in other words, each n-gram has the same occurrence number.

*N = 100 000*

##### Test Result Charts

- For n = 1 (the 1 to 0 correlation in the sample sequence):

 **![img](https://lh6.googleusercontent.com/p9rZ2AhufvjnOLOE5eqf2jO2KWqaifd71xdunhPra8Oy8Zk2My8QKyTNWkeFaM9aNgOJ16hupc53vJb8hP4fXzlCd3HVWBEpJ-SLZfMX6DQ103-b1QdMkvxoVzjG9h8bOiPmXqzB)* 

  **![img](https://lh3.googleusercontent.com/TtbDPfRTB68Z7EEafIzVS33wbNo-zP7sDx6joTWNW1BOxZWiYcJQmMPE48RrN1gEtFtDYmA1ROEQEeyPYj97CzwZVrokHc0borzgpU5pIJ41uwI0f4silob2Kvl-8QnI-uAOD9W_)** 
   **![img](https://lh6.googleusercontent.com/_RqLN4-gsCczA1csxhrILjJEzpbwLTiNYd5rsN8umP-YgDh51XwXde0js1_i01ouj8bGRW8LLyzuhKwla5mZzfZn_A--v6-_EF77VpzdDkIE7AhMTo5JuOmkrn2CdsAaj5Cfbq6o)**

- For n = 2:

  **![img](https://lh5.googleusercontent.com/xgf0abg8iqBIcHqOOrVtgAUNIF1HhiXE_mAw7OewXBfy62_8ipf4OXzJWlNvgfKIb-Te8W9LxlSQ0ZwqLFRj1ODRdAl5qzYdpMp5MiLFdgOfzJ17GRkLInqVDt75KuJR5ovSpp3a)** 

  **![img](https://lh4.googleusercontent.com/ZRzsaaFCq8BeXKsLtfnaRGNpixtIN8bVt7zFuZEDCxpBjmku5DRZB17RC2h_BF5gJb_UBXgwi13PawGAeDKp5WXcpWLjy_3Jbupe9XkRxgYX3D3xLjoCapnjJbvJy4a6ZM3gxN_n)** 

  **![img](https://lh3.googleusercontent.com/AxTf-nIcEyE4WDF5N7Pj4NkEdBEcBaIVanvqURQMJD7LqbOKeqf1wICkPcGuBlfU4yWl__Meku4uOd5lKj6RVY4X9IumJZ6YooO2dLkELSn8_FIwL5lzRGxo9T9wu0RXb8JjWTh6)** 


- For n = 3:

  *![img](https://lh4.googleusercontent.com/Pq_w1GXnwOo-Fme4TQUQXTp9PcaSyYFI5P4m_yYbrjPZ1s-hx8hNkXXiqlEuxdVNSwniobltn7xwmFoiQY6iwvUT_PTa1JMLHmBOEzMJYWt6tklrlLIO4v6eQMrSexQi5Av7PUxg)* 

  **![img](https://lh5.googleusercontent.com/bO-UfNitGmMuR97yEtDXVDGC-qeVtHcMH9or1GSB6ZTroLhkRohyDJhbPtBnT5O8Wx77xCdqfWGZRKr8c58B95uucOED7W2A-Znx3XhPCnZWpDZNk4HNoRZlmordYjzq-aPAiI3O)** 

  **![img](https://lh3.googleusercontent.com/bTQYmLUWd38JVbHtqAZBNI6DG_EHyjuJsjin8MZ625xB2efl0sNSgRssbgk4c_iEvgiS4Jt096T6Hp8oGZpPz4cAQnzaoZjleub62eoQyZ4rCBLjQ13hqr0X9XkiNmrSXF1jrad9)** 

The results satisfy the sequence requirements (properties are close to truly random), the amount of n-grams is almost the same.

#### Evaluating Monotonicity

For a sequence with statistical qualities close to truly random, possibility of non-increasing (or non-decreasing) sectors depends on its length: the longer the sequence, the smaller the probability. Random sequences cannot face long non-increasing (or non-decreasing) sectors.

*N = 20 000*

##### Test Result Charts

The bars of the charts below show the size of monotonous subsequences within the tested sequence. It is clearly visible that most part of monotonous subsequences contain 2 elements or less. The longest contains 7 elements. These results allow concluding that generated numbers are close to being truly random.

**![img](https://lh4.googleusercontent.com/qXvPHqGayAuoXGHt1-63rRc2Mns_HbzwmlPa28hIBVMNTGOWBCQTvzlI178hbLwmE74FqjhecjaDt0cAx98YPyd4UBqI8QGxCdeYF53wfCUPU0V-EWAcWMHHlBdPOOAULl6itczH)** 

  **![img](https://lh6.googleusercontent.com/BwSCa3X2Nv9gdDO77ok6e0hunfo3mD3T2mMoKX-nhjK1qmx5yGwCi2wJLur25QmZCzOon-6uWiFNqg2R3hZKzDAbHgtszZH_M6ZdIBD6HjZtHhsFZWsvAOqxqELxbE6ElyAzyxsD)** 

#### Autocorrelation Plot (Correlograms)

The test is designed to check correlation of shifts within the sequence.
The tested sequence has to be normalized in order to construct autocorrelation. Let <a href="http://www.codecogs.com/eqnedit.php?latex=a_{R-1}a_{R-2}...a_{0}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?a_{R-1}a_{R-2}...a_{0}" title="a_{R-1}a_{R-2}...a_{0}" /></a> be a binary representation of an *i* element of the sequence. 

Therefore, its normalized value is:

<a href="http://www.codecogs.com/eqnedit.php?latex=b_{i}=\sum_{j=0}^{R-1}(-1)^{a_{j}}*2^{j}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?b_{i}=\sum_{j=0}^{R-1}(-1)^{a_{j}}*2^{j}" title="b_{i}=\sum_{j=0}^{R-1}(-1)^{a_{j}}*2^{j}" /></a>

The next step is to compute the correlation lags between the shifted sequence copies. The following formula applies:

<a href="http://www.codecogs.com/eqnedit.php?latex=c_{j}=\frac{\sum_{j=0}^{n-1}b_{i}*b_{i&plus;j}mod\,&space;n}{\sum_{j=0}^{n-1}b^{2}_{i}}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?c_{j}=\frac{\sum_{j=0}^{n-1}b_{i}*b_{i&plus;j}mod\,&space;n}{\sum_{j=0}^{n-1}b^{2}_{i}}" title="c_{j}=\frac{\sum_{j=0}^{n-1}b_{i}*b_{i+j}mod\, n}{\sum_{j=0}^{n-1}b^{2}_{i}}" /></a>



For a sequence close to truly random the correlation lags value is supposed to be close to zero at all shifting points.  

*N = 10 000*  

##### Test Result Charts

**![img](https://lh3.googleusercontent.com/zimkIGQZjLbgNauJDT_sNQHWOVQp79dXQWsz40Jnf6v-npxI757C5ryXCxXWYGV9DEQRdv5WuRe4X4-AV6FcT-BVthkRXyLm0o0E26YanuJ6bS7iLdo7WDwyumuzbO37PuQWWL2V)** 

**![img](https://lh4.googleusercontent.com/XNGzaPrBhom_QGeSvTbr6MfJ9Obc0galxR6VcxB462fkclpeLoeJ9kEI4J2XsBYtOOILYxgAYoeOmxInkMVSBpABAhP2Hp2ytostxl9hfpCwHRvvpXU2PxD2oSByrhu6Gc84sYZE)** 

At all shifting points correlation lag values are  close to zero showing that each tested sequence is close to truly random.

## NIST Statistical tests <a name="niststatisticaltests"></a>

NIST Statistical Test Suite is a suite of 15 tests intended for defining the closeness of a binary sequence to truly random. These tests are based on various statistic properties on characteristic of truly random sequences.
We've generated a test sequence of 100,000 elements in counter mode (we chose this mode for the same reason we had for graphic tests). The sample size predetermined the use of the following tests:

- Frequency (Monobit) Test

- Frequency Test within a Block

- Cumulative Sums (Cusums) Test

- Runs Test

- Tests for the Longest-Run-of-Ones in a Block

- Binary Matrix Rank Test

- Discrete Fourier Transform (spectral) Test

- Non-overlapping Template Matching Test

- Approximate Entropy Test

- Serial Test

The idea of these tests is likely to coincide with some of the graphical tests above. Yet, these provide a particular ranking, that does not necessarily depend on checker’s opinion, therefore rechecking is reasonable.  

For test results download the [tests_result.txt](http://google.com). A test is considered successful, if  *P-value > 0.01* and  *PROPORTION > 0.800*. 

For detailed coverage of each test, additional documentation and testing software guidelines, follow the links:

- https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software
- https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf

