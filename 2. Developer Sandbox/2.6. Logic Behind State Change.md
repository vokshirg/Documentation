DAO.Casino uses its variation of State Channel (an extended custom version of Payment Channels tailored to the gambling industry). Basically, our Game Channels ensure interaction between the game participants and smart contracts.

# Channel Life-Cycle

By and large, the channel life-cycle is similar the life-cycle of a game itself. Below you can find detailed specification for each stage.

## Opening

To open the channel, the player side makes a signed request to the bankroller to open the channel. The bankroller checks data and calls the `openChannel` function. Then, BET tokens are written off the parties' accounts and deposited into the newly created contract.

```javascript
openChannel(id, player, bankroller, playerDeposit, bankrollDeposit, session, time, gameData, N, E ,sign)
```

## Update

In the course of the game, the parties exchange signatures to update the channel status in the blockchain.

Any moment either party can update the status in the the smart contract by calling the `updateChannel` function; the other party has to sign it for verification. Previous status expires.

```javascript
updateChannel(id, playerBalance, bankrollBalance, session, sign)
```

## Closing

Closing the channel means triggering funds distribution between participants according tot he last status. A channel can be closed upon its expiration or by mutual consent of the participants.

In the first case  `closeByTime`function is used and the latest status is used to calculate the result.

```javascript
closeByTime(id)
```

### By **participant consent**

In this case a party desiring to close the channel, seds a signed request to the other party. If accepted, the `closeByConsert` function is called.

```javascript
closeByConsent(id, playerBalance, bankrollBalance, session, close, sign)
```

## Dispute

In case of dispute/suspected fraud, an offended party may initiate a dispute. The other party then has a temporary window (*n blocks*) to provide evidence of fair play. If it fails, the game ends in favor of the deceived party.

### **open dispute**

Either the player or the bankroller can open a dispute. To do it, a party has to update the channel status to the one signed by the both parties. Then, the party has to supply the last game data to the contract. The contract validates input and, in case of success, creates a dispute case. Then, the  other side gets a time span to resolve the dispute. 

```javascript
openDispute(id, session, disputeSeed, disputeBet, gameData, sign)
```

### **close dispute**

In the course of time allocated to resolve the dispute the suspected party can either actualize the channel status updating to the mutually signed one, or provide the game round data to the smart contract. Then, the funds are redistributed according to the status and game results; the channel is then closed.

```javascript
closeDispute(id, N, E, rsaSign)
```

**close by dispute**

If the suspected party fails to provide evidence of fair play within the allocated deadline, the contract plays the game (if dispute initiated by the player) or uses the previously obtained random (if initiated by the bankroller). 

```javascript
closeByDispute(id)
```

## Process Logic

1. At the beginning of each game a player has to provide a deposit (BET to be sent to a new game).

2. In response, dc-webapi finds an appropriate bankroller in the defined list that processes required amounts.

3. Then, the script requests the selected bankroller to open a payment channel for the game.

4. The bankroller makes a request to open channel to the contract. It is where player deposits are stored.

5. In the course of the game the balance is updated by the `payChannel.updateBalance(-1)` function in the following way: 

   _`self.payChannel.updateBalance( +1 )`

   `_self.payChannel.updateBalance( -1 )`

6. Once the game is over, the player requests the bankroller to close the channel.

7. The bankroller checks the game result and closes the channel.

8. The contract distributes funds between players.


